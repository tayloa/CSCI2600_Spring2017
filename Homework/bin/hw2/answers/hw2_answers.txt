Problem 1:
	precondition: arr.length = len && len >= 0
	int sum = 0;
	int i = len - 1;
	while ( i >= 0 ) {
	  sum = sum + arr[i];
	  i = i - 1;
	}
	postcondition: (result is the sum of all elements on array arr)
	
	LI:i < len && sum = arr[0]+arr[1]+...+arr[i] 
	Proof:
	Base Case: Outside the loop
	  sum = 0, i = len - 1
	  Holds because i is less than the length at the start and the sum is 0. No array values have been added yet.
	Induction Step: Assuming the LI holds for iteration k, does it hold for k+1?
	sum_new = sum + arr[i]
	i_new = i - 1
	
	sum_new = arr[i_new + 1]+...+ arr[0]
	        = arr[i] +..+ arr[0]
	Because i decrements by 1 at each step and starts with the value len - 1, it will always be less than len.i will 
	eventually become -1, at which out loop will break. Since the invariant holds for the k-th iteration, and our exit 
	condition meets the post condition, our code and invariant are valid.
	
	The algorithm would have the same runtime after the change. n steps are still taken. It was very easy to prove the 
	invariant after the change as well.
	
Problem 2:
	function: dutch_flag(arr)
	input: unsorted array of reds and blues with median k
	output: array with all reds to the left and blue to the right
	    low = 0
	    high = len(arr)-1
	    k = len(arr)/2
	    while low < k && high >= k:
	      if arr[low] = "blue":
	        swap(arr,arr[low],arr[high])
	        low++ 
	      else if arr[high] = "red":
	        swap(arr,arr[high],arr[low])
	        high--
	
	LI: low < high && low < k && high >= k        
	Postcondition: {for i in range[0:k], arr[i] = "red" && 
	                for i in range[k+1,N-1], arr[i] = "blue"}
Problem 3:
	LI: m^n = result*x^y
	Base Case: m^n = 1 * x^y = 1 * m^n
	Assuming the LI holds for the k-th iteration, we can prove it holds for the k+1 iteration.
	Case 1: y is even
	x_k+1 = x_k * x_k
	y_k+1 = y_k / 2
	result_k * x_k+1 ^ y^k+1
	result_k * (x_k * x_k)^(y_k/2)
	result_k * (x_k^(y_k/2)) * (x_k^(y_k/2))
	result_k * x_k^(y_k/2 + y_k/2)
	result_k * x_k^(2(y_k/2))
	result_k * x_k^(y_k)
	
	Case 2: y is uneven
	result_k+1 = result_k * x_k
	y_k+1 = y_k - 1
	result_k+1 * x_k+1 ^ y^k+1
	(result_k * x_k) * x_k^(y^k - 1)
	result_k * x_k * x_k^(y^k - 1)
	result_k * x_k^(y_k)
	
	Every other iteration, y is halved. Since y is an int and not a float, it will eventually become 0 and the loop will exit.
	If the loop terminates, we know y = 0. Since the LI, m^n = result*x^y, holds, we have result = m^n.
	m^n = result*x^y
	y = 0
	    = result * x^0
	m^n = result
	
Every other iteration in the loop decrements y. We can establish a decrementing function D = y.
	Case 1:
		D_0 = y_0
		y_1 = y_0 / 2
		D_1 = y_1 = y_0 / 2 = D_0 / 2
		D_0 / 2 < D_0
	Case 2:
	    D_0 = y_0
		y_1 = y_0 - 1
		D_1 = y_1 = y_0 - 1 = D_0 - 1
		D_0 - 1 < D_0
		
Problem 4:
	Outer LI: 0 <= r <= n && u == Factorial(r)
	Base Case:
	u = 1 --> Factorial(1) = 1
	r = 0 --> 0 <= r
	Assuming the Outer LI holds for the base case, show it holds for the k+1 iteration.
	u_k+1 = u_k * v_k
	r_k+1 = r_k + 1
	0 <= r_k + 1 <= n --> 0 <= r_k <= n - 1
	Factorial(r_k+1) = Factorial(r_k + 1) = Factorial(r_k) * Factorial(1) = Factorial(r_k)

	Inner LI: 1<=s<=r+1 && u == v * s
	Base Case:
	r = 0
	s = 1
	u = 1
	v = u
	1 <= s <= r+1 --> 1 <= 1 <= 1
	u = v * s --> 1 = 1 * 1
	Assuming the Inner LI holds for the base case, show it holds for the k+1 iteration.
	r_k = 0
	s_k+1 = s_k + 1
	u_k+1 = u_k + v_k
	v_k = u_k
	1 <= s_k + 1 <= r_k + 1 --> 1 <= s_k <= r_k
	u_k+1 = u_k + v_k = v_k(s_k + 1)
	                  = v_k(s_k) + v_k
	              u_k = v_k(s_k) + v_k - v_k
	              u_k = v_k * s_k 
Dafny code:
function Factorial(n: int): int
 requires n >= 0
{
 if n == 0 then 1 else n * Factorial(n-1)
}

method LoopyFactorial(n: int) returns (u: int)
 requires n >= 0
 ensures u == Factorial(n)
 {
 u := 1;
 var r := 0;
 while (r < n)
   invariant 0 <= r <= n && u == Factorial(r);
 {
  var v := u;
  var s := 1;
  while (s<=r)
    invariant 1 <= s<= r+1 && u == v * s;
  {
    u:=u+v;
    s:=s+1;
  }
  assert v <= u;
  r:=r+1;
 }
}